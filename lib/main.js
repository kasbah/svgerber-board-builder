// Generated by CoffeeScript 1.9.3
(function() {
  var _, bottom, build, convert, convertGerber, defaultStyle, filterBoardLayers, fs, gerberToSvg, i, idLayer, layerOptions, layers, len, options, p, path, ref, styleToSvgObj, svg, top;

  gerberToSvg = require('gerber-to-svg');

  _ = require('lodash');

  layerOptions = require('./layer-options');

  idLayer = require('./identify-layer');

  build = require('./build-board');

  options = require('./color-options');

  styleToSvgObj = function(arg) {
    var copperFinish, silkScreen, solderMask;
    copperFinish = arg.copperFinish, solderMask = arg.solderMask, silkScreen = arg.silkScreen;
    return {
      style: {
        type: 'text/css',
        _: ".Board--board { color: dimgrey; } .Board--cu { color: lightgrey; } .Board--cf { color: " + options.cf[copperFinish].bg + "; } .Board--sm { color: " + options.sm[solderMask].bg + "; opacity: 0.75; } .Board--ss { color: " + options.ss[silkScreen].bg + "; } .Board--sp { color: silver; } .Board--out { color: black; }"
      }
    };
  };

  defaultStyle = {
    copperFinish: 'gold',
    solderMask: 'green',
    silkScreen: 'white'
  };

  convertGerber = function(filename, gerber) {
    var e, e2, obj, string, warnings;
    warnings = [];
    if (typeof gerber === 'object') {
      obj = gerber;
    } else {
      try {
        obj = gerberToSvg(gerber, {
          object: true,
          warnArr: warnings
        });
      } catch (_error) {
        e = _error;
        try {
          warnings = [];
          obj = gerberToSvg(gerber, {
            drill: true,
            object: true,
            warnArr: warnings
          });
        } catch (_error) {
          e2 = _error;
          warnings = [];
          obj = {};
        }
      }
    }
    if (obj.svg != null) {
      string = gerberToSvg(obj);
    } else {
      string = '';
    }
    return {
      filename: filename,
      svgObj: obj,
      svgString: string,
      warnings: warnings
    };
  };

  filterBoardLayers = function(layers, side) {
    var ls;
    ls = layers.filter(function(layer) {
      var opt;
      opt = _.find(layerOptions, {
        val: layer.type
      });
      return (opt != null ? opt.side : void 0) === side || (opt != null ? opt.side : void 0) === 'both';
    });
    return _.cloneDeep(ls);
  };

  convert = function(gerbers, style, output) {
    var bottomLayers, g, i, layers, len, svgObj, svgObjBottom, svgObjTop, topLayers, type;
    if (style == null) {
      style = defaultStyle;
    }
    if (output == null) {
      output = 'string';
    }
    layers = [];
    for (i = 0, len = gerbers.length; i < len; i++) {
      g = gerbers[i];
      svgObj = convertGerber(g.filename, g.gerber).svgObj;
      type = idLayer(g.filename);
      layers.push({
        svgObj: svgObj,
        type: type
      });
    }
    topLayers = filterBoardLayers(layers, 'top');
    svgObjTop = build('top', topLayers);
    svgObjTop.svg._.push(styleToSvgObj(style));
    bottomLayers = filterBoardLayers(layers, 'bottom');
    svgObjBottom = build('bottom', bottomLayers);
    svgObjBottom.svg._.push(styleToSvgObj(style));
    switch (output) {
      case 'string':
        return {
          top: gerberToSvg(svgObjTop),
          bottom: gerberToSvg(svgObjBottom)
        };
      case 'object':
        return {
          top: svgObjTop,
          bottom: svgObjBottom
        };
    }
  };

  if (require.main !== module) {
    module.exports = convert;
  } else {
    fs = require('fs');
    path = require('path');
    layers = [];
    ref = process.argv.slice(2);
    for (i = 0, len = ref.length; i < len; i++) {
      p = ref[i];
      layers.push({
        filename: path.basename(p),
        gerber: fs.readFileSync(p, 'utf8')
      });
    }
    svg = convert(layers);
    top = fs.openSync('top.svg', 'w');
    bottom = fs.openSync('bottom.svg', 'w');
    fs.writeSync(top, svg.top);
    fs.writeSync(bottom, svg.bottom);
  }

}).call(this);
