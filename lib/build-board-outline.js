// Generated by CoffeeScript 1.9.3
(function() {
  var Point, Segment, find, remove;

  find = require('lodash/collection/find');

  remove = require('lodash/array/remove');

  Point = (function() {
    function Point(x1, y1) {
      this.x = x1;
      this.y = y1;
      this.segments = [];
    }

    Point.prototype.addSegment = function(seg, rel) {
      return this.segments.push({
        seg: seg,
        rel: rel
      });
    };

    return Point;

  })();

  Segment = (function() {
    function Segment(start1, end1) {
      this.start = start1;
      this.end = end1;
      this.start.addSegment(this, 'start');
      this.end.addSegment(this, 'end');
    }

    Segment.prototype.addArc = function(radius, largeArc, sweep1) {
      this.radius = radius;
      this.largeArc = largeArc;
      this.sweep = sweep1;
    };

    Segment.prototype.drawTo = function(point) {
      var sw, toEnd, toStart;
      if (point === this.start) {
        toStart = true;
      } else if (point === this.end) {
        toEnd = true;
      }
      if ((this.radius == null) && (toStart || toEnd)) {
        return ['L', point.x, point.y];
      } else if ((this.radius != null) && toEnd) {
        return ['A', this.radius, this.radius, 0, this.largeArc, this.sweep, point.x, point.y];
      } else if ((this.radius != null) && toStart) {
        sw = this.sweep === 1 ? 0 : 1;
        return ['A', this.radius, this.radius, 0, this.largeArc, sw, point.x, point.y];
      } else {
        return [];
      }
    };

    return Segment;

  })();

  module.exports = function(outline) {
    var end, i, j, len, lrgArc, newEnd, newPath, newStart, nextPoint, nextPointRel, nextSeg, nextSegObj, nextSegRel, p, pathStart, points, r, ref, seg, start, startPoint, sweep, x, y;
    if (outline[0] !== 'M') {
      console.log("didn't start with 'M'");
      return [];
    }
    pathStart = null;
    points = [];
    i = 0;
    while (i < outline.length - 1) {
      if (outline[i] === 'M' || outline[i] === 'L') {
        x = outline[i + 1];
        y = outline[i + 2];
        i += 3;
      } else if (outline[i] === 'A') {
        x = outline[i + 6];
        y = outline[i + 7];
        i += 8;
      } else if (outline[i] === 'Z') {
        i++;
        continue;
      }
      if (i >= outline.length) {
        break;
      } else {
        start = find(points, {
          x: x,
          y: y
        });
        if (start == null) {
          newStart = true;
          start = new Point(x, y);
        }
      }
      if (outline[i] === 'L') {
        x = outline[i + 1];
        y = outline[i + 2];
        r = null;
      } else if (outline[i] === 'A') {
        x = outline[i + 6];
        y = outline[i + 7];
        r = outline[i + 2];
        lrgArc = outline[i + 4];
        sweep = outline[i + 5];
      } else if (outline[i] === 'M') {
        continue;
      }
      if (outline[i] === 'Z') {
        end = pathStart;
        pathStart = null;
      } else {
        if (pathStart == null) {
          pathStart = start;
        }
        end = find(points, {
          x: x,
          y: y
        });
        if (end == null) {
          newEnd = true;
          end = new Point(x, y);
        }
      }
      seg = new Segment(start, end);
      if (r != null) {
        seg.addArc(r, lrgArc, sweep);
      }
      if (newStart) {
        newStart = false;
        points.push(start);
      }
      if (newEnd) {
        newEnd = false;
        points.push(end);
      }
    }
    newPath = [];
    while (points.length) {
      startPoint = points.pop();
      nextSegObj = startPoint.segments.pop();
      nextPoint = null;
      newPath.push('M', startPoint.x, startPoint.y);
      while (nextPoint !== startPoint) {
        remove(points, function(p) {
          return p === nextPoint;
        });
        nextSeg = nextSegObj.seg;
        nextSegRel = nextSegObj.rel;
        nextPointRel = nextSegRel === 'start' ? 'end' : 'start';
        nextPoint = nextSeg[nextPointRel];
        ref = nextSeg.drawTo(nextPoint);
        for (j = 0, len = ref.length; j < len; j++) {
          p = ref[j];
          newPath.push(p);
        }
        remove(nextPoint.segments, function(sO) {
          return sO.seg === nextSeg;
        });
        nextSegObj = nextPoint.segments.pop();
      }
    }
    return newPath;
  };

}).call(this);
