// Generated by CoffeeScript 1.9.3
(function() {
  var boardOutline, reCOPPER, reDRILL, reEDGE, reMASK, rePASTE, reSILK, unique, uniqueId;

  boardOutline = require('./build-board-outline');

  unique = 0;

  uniqueId = function() {
    return unique++;
  };

  reCOPPER = /cu/;

  reMASK = /sm/;

  reSILK = /ss/;

  rePASTE = /sp/;

  reEDGE = /out/;

  reDRILL = /drl/;

  module.exports = function(name, layers) {
    var addVboxToBbox, attr, bbox, bboxRect, copper, cuFinishId, d, defs, draw, drill, e, edge, edgeBbox, getVboxFromBbox, group, i, j, k, key, l, layer, layerId, len, len1, len2, len3, len4, ly, m, mask, mechId, mechMask, n, newPathData, node, oldSW, paste, path, ref, ref1, ref2, ref3, scale, silk, smId, smPos, svg, trans, u, units, val, vb, vbScale, vbox, xml;
    if (layers == null) {
      layers = [];
    }
    copper = null;
    mask = null;
    silk = null;
    paste = null;
    edge = null;
    drill = [];
    attr = {};
    defs = [];
    draw = [];
    bbox = [Infinity, Infinity, -Infinity, -Infinity];
    edgeBbox = null;
    units = 'px';
    scale = null;
    addVboxToBbox = function(v) {
      var xMax, yMax;
      xMax = v[2] + v[0];
      yMax = v[3] + v[1];
      if (v[0] < bbox[0]) {
        bbox[0] = v[0];
      }
      if (v[1] < bbox[1]) {
        bbox[1] = v[1];
      }
      if (xMax > bbox[2]) {
        bbox[2] = xMax;
      }
      if (yMax > bbox[3]) {
        return bbox[3] = yMax;
      }
    };
    getVboxFromBbox = function(bb) {
      return [bb[0], bb[1], bb[2] - bb[0], bb[3] - bb[1]];
    };
    for (i = 0, len = layers.length; i < len; i++) {
      layer = layers[i];
      ly = layer.type;
      xml = layer.svgObj;
      if (xml.svg == null) {
        continue;
      }
      addVboxToBbox(xml.svg.viewBox);
      u = (ref = xml.svg.width.match(/(in)|(mm)/)) != null ? ref[0] : void 0;
      if (units === 'px') {
        units = u;
      } else if (u !== units) {
        return {};
      }
      vbScale = parseFloat(xml.svg.width) / xml.svg.viewBox[2];
      if (scale == null) {
        scale = vbScale;
      } else if (Math.abs(vbScale - scale) > 0.0000001) {
        return {};
      }
      ref1 = xml.svg;
      for (key in ref1) {
        val = ref1[key];
        if ((attr[key] == null) && key !== '_') {
          attr[key] = val;
        }
      }
      layerId = name + "-" + ly + "_" + (uniqueId());
      ref2 = xml.svg._;
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        node = ref2[j];
        if (node.defs != null) {
          ref3 = node.defs._;
          for (k = 0, len2 = ref3.length; k < len2; k++) {
            d = ref3[k];
            defs.push(d);
          }
        } else if (node.g != null) {
          delete node.g.transform;
          node.g.id = layerId;
          defs.push(node);
        }
      }
      if (reCOPPER.test(ly)) {
        copper = layerId;
      } else if (reMASK.test(ly)) {
        mask = layerId;
      } else if (reSILK.test(ly)) {
        silk = layerId;
      } else if (rePASTE.test(ly)) {
        paste = layerId;
      } else if (reDRILL.test(ly)) {
        drill.push(layerId);
      } else if (reEDGE.test(ly)) {
        edge = layerId;
        group = defs[defs.length - 1].g._;
        for (l = 0, len3 = group.length; l < len3; l++) {
          n = group[l];
          if ((n.path != null) && n.path['stroke-width']) {
            if (typeof path === "undefined" || path === null) {
              path = n.path;
            } else {
              path.d = path.d.concat(n.path.d);
            }
          }
        }
        newPathData = [];
        try {
          newPathData = boardOutline(path.d);
        } catch (_error) {
          e = _error;
        }
        if (newPathData.length) {
          oldSW = path['stroke-width'];
          path['stroke-width'] = 0;
          path.fill = '#fff';
          path['fill-rule'] = 'evenodd';
          path.d = newPathData;
          vb = xml.svg.viewBox;
          vb[0] += oldSW / 2;
          vb[1] += oldSW / 2;
          vb[2] -= oldSW;
          vb[3] -= oldSW;
          edgeBbox = [vb[0], vb[1], vb[2] + vb[0], vb[3] + vb[1]];
        }
      }
      xml = null;
    }
    if (copper == null) {
      return {};
    }
    if (edgeBbox != null) {
      bbox = edgeBbox;
    }
    vbox = getVboxFromBbox(bbox);
    bboxRect = function(cls, fill) {
      if (cls == null) {
        cls = 'Board--cover';
      }
      if (fill == null) {
        fill = 'currentColor';
      }
      return {
        rect: {
          "class": cls,
          fill: fill,
          x: vbox[0],
          y: vbox[1],
          width: vbox[2],
          height: vbox[3]
        }
      };
    };
    draw.push(bboxRect('Board--board'));
    draw.push({
      use: {
        "class": 'Board--cu',
        'xlink:href': "#" + copper
      }
    });
    if (mask != null) {
      cuFinishId = name + "-sm_" + (uniqueId());
      defs.push({
        mask: {
          id: cuFinishId,
          color: '#fff',
          _: [
            {
              use: {
                'xlink:href': "#" + copper
              }
            }
          ]
        }
      });
      draw.push({
        use: {
          "class": 'Board--cf',
          mask: "url(#" + cuFinishId + ")",
          'xlink:href': "#" + mask
        }
      });
      smId = name + "-sm_" + (uniqueId());
      defs.push({
        mask: {
          id: smId,
          color: '#000',
          _: [
            bboxRect(null, '#fff'), {
              use: {
                'xlink:href': "#" + mask
              }
            }
          ]
        }
      });
      smPos = {
        g: {
          mask: "url(#" + smId + ")",
          _: [bboxRect('Board--sm')]
        }
      };
      if (silk != null) {
        smPos.g._.push({
          use: {
            "class": 'Board--ss',
            'xlink:href': "#" + silk
          }
        });
      }
      draw.push(smPos);
    }
    if (paste != null) {
      draw.push({
        use: {
          "class": 'Board--sp',
          'xlink:href': "#" + paste
        }
      });
    }
    if ((edge != null) && (edgeBbox == null)) {
      draw.push({
        use: {
          "class": 'Board--out',
          'xlink:href': "#" + edge
        }
      });
    }
    mechId = null;
    if (drill.length || (edgeBbox != null)) {
      mechId = name + "-mech_" + (uniqueId());
      mechMask = {
        mask: {
          id: mechId,
          color: '#000',
          _: []
        }
      };
      mechMask.mask._.push(edgeBbox != null ? {
        use: {
          'xlink:href': "#" + edge
        }
      } : bboxRect(null, '#fff'));
      for (m = 0, len4 = drill.length; m < len4; m++) {
        d = drill[m];
        mechMask.mask._.push({
          use: {
            'xlink:href': "#" + d
          }
        });
      }
      defs.push(mechMask);
    }
    if (name === 'bottom') {
      trans = "translate(" + (bbox[2] + bbox[0]) + "," + (bbox[3] + bbox[1]) + ") scale(-1,-1)";
    } else {
      trans = "translate(0," + (bbox[3] + bbox[1]) + ") scale(1,-1)";
    }
    draw = {
      g: {
        transform: trans,
        _: draw
      }
    };
    if (mechId) {
      draw.g.mask = "url(#" + mechId + ")";
    }
    svg = attr;
    svg["class"] = 'Board';
    svg.viewBox = getVboxFromBbox(bbox);
    svg.width = "" + (svg.viewBox[2] * scale) + units;
    svg.height = "" + (svg.viewBox[3] * scale) + units;
    svg._ = [];
    if (defs.length) {
      svg._.push({
        defs: {
          _: defs
        }
      });
    }
    if (draw.g._.length) {
      svg._.push(draw);
    }
    return {
      svg: svg
    };
  };

}).call(this);
